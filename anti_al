		if (data->objs)
			obj->next = data->objs;
		data->objs = obj;
		if (data->negative_objs)
			obj->next = data->negative_objs;
		data->negative_objs = obj;
if (data->objs)
cone->next = data->objs;
data->objs = cone;
	if (data->scene_name)
		ft_strdel(&data->scene_name);
	data->scene_name = ft_strsub(*line, start, len - start);
if (data->objs)
rect->next = data->objs;
data->objs = rect;
	if (data->objs)
		cyclide->next = data->objs;
	data->objs = cyclide;
  if (data->objs)
  cylinder->next = data->objs;
  data->objs = cylinder;
if (data->objs)
ellipsoid->next = data->objs;
data->objs = ellipsoid;
	if (data->objs)
		fermat->next = data->objs;
	data->objs = fermat;
if (data->objs)
horse_saddle->next = data->objs;
data->objs = horse_saddle;
if (data->objs)
hyperboloid->next = data->objs;
data->objs = hyperboloid;
	if (!data->info)
		if (!(data->info = malloc(sizeof(t_mlx))))
		data->info->win_ptr = mlx_new_window(data->mlx->mlx_ptr, 400, 500, "Informations");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 150, 10, 0xFFFFFF, "Controls");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 10, 60, 0xFFFFFF, "Cam Mode :");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 100, 0xFFFFFF, "ESC          ==> Quit Program");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 125, 0xFFFFFF, "W / S        ==> Forward / Backward");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 150, 0xFFFFFF, "A / D        ==> Left / Right");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 175, 0xFFFFFF, "UP / DOWN    ==> Rotate Verticaly");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 200, 0xFFFFFF, "LEFT / RIGHT ==> Rotate Horizontaly");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 225, 0xFFFFFF, "SPACE        ==> Up");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 250, 0xFFFFFF, "SHIFT        ==> Down");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 275, 0xFFFFFF, "LEFT CLICK   ==> Select Object");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 10, 325, 0xFFFFFF, "Mode Move_Object :");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 375, 0xFFFFFF, "W, A, S, D   ==> Translate Object");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 400, 0xFFFFFF, "ARROWS       ==> Rotate Object");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 425, 0xFFFFFF, "SPACE        ==> Up Object");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 450, 0xFFFFFF, "SHIFT        ==> Down Object");
		mlx_string_put(data->mlx->mlx_ptr, data->info->win_ptr, 5, 475, 0xFFFFFF, "LEFT CLICK   ==> Unselect Object");
	data->mlx = mlx;
			data->size.val[0], data->size.val[1], data->scene_name);
			data->size.val[0], data->size.val[1]);
	if (data->size.val[0] < 400 || data->size.val[0] > 2560 || data->size.val[1] < 400 || data->size.val[1] > 1420)
	if (!(data->mlx = init_mlx(data)))
		free(data->objs);
		free(data->objs);
		free(data->mlx);
//	if ((data->caustics_gi || data->indirect_gi) && !(create_photon_map(data)))
	data->rot_mat[0] = init_rotation_matrix_x(degree_to_radian(data->camera->rotation.val[0]));
	data->rot_mat[1] = init_rotation_matrix_y(degree_to_radian(data->camera->rotation.val[1]));
	data->f = 1;
	data->hooks = 0;
	data->fps = 0;
	data->delta_time = 0;
	data->aa_adapt = 1;
   data->params.m_rotcam_y = 1;
   data->params.p_rotcam_y = 1;
   data->params.m_rotcam_x = 1;
   data->params.p_rotcam_x = 1;
   data->proj = data->proj == PERSP ? ORTO : PERSP;
   data->params.ym_from = 1;
   data->params.yp_from = 1;
   data->params.fun_on = data->params.fun_on ? 0 : 1;
   data->params.p_cam_speed = 1;
   data->params.m_cam_speed = 1;
		data->hooks |= A_KEY;
	//data->cam.origin[0] -= 0.2;
		data->hooks |= S_KEY;
	//data->cam.origin[2] -= 0.2;
		data->hooks |= D_KEY;
	//data->cam.origin[0] += 0.2;
		data->hooks |= W_KEY;
		data->hooks |= F_KEY;
		data->hooks |= G_KEY;
		data->hooks |= ARR_LEFT_KEY;
		data->hooks |= ARR_RIGHT_KEY;
		data->hooks |= ARR_DOWN_KEY;
		data->hooks |= ARR_UP_KEY;
		data->hooks |= SPACE_KEY;
		data->hooks |= SHIFT_KEY;
		SDL_Surface	*img_save = SDL_CreateRGBSurfaceFrom((void *)data->mlx->img_str, (int)data->size.val[0], (int)data->size.val[1], 32, 4 * (int)data->size.val[0], 0xff << 16, 0xff << 8, 0xff << 0, 0x0);
		image_file_name = get_image_file_name(data->scene_name);
	//	else if (keycode == 69 && data->anti_al < MAX_ANTI_AL)
	//		data->anti_al++;
	;/*		data->params.xp_from = 1;
			data->params.xm_from = 1;
			data->params.zp_from = 1;
			data->params.zm_from = 1;
			data->params.p_rotcam_z = 1;
			data->params.m_rotcam_z = 1;
			else if (keycode == 49 && data->line_nbr * data->line_size < 25000)
			data->fill = data->fill ? 0 : 1;
			data->params.p_speed = 1;
			data->params.m_speed = 1;
   data->params.p_rotcam_y = 0;
   data->params.m_rotcam_x = 0;
   data->params.p_rotcam_x = 0;
   data->params.ym_from = 0;
   data->params.yp_from = 0;
   data->params.p_cam_speed = 0;
   data->params.m_cam_speed = 0;
		data->hooks -= A_KEY;
	//data->cam.origin[0] -= 0.2;
		data->hooks -= S_KEY;
	//data->cam.origin[2] -= 0.2;
		data->hooks -= D_KEY;
	//data->cam.origin[0] += 0.2;
		data->hooks -= W_KEY;
		data->hooks -= F_KEY;
		data->hooks -= G_KEY;
		data->hooks -= ARR_LEFT_KEY;
		data->hooks -= ARR_RIGHT_KEY;
		data->hooks -= ARR_DOWN_KEY;
		data->hooks -= ARR_UP_KEY;
		data->hooks -= SPACE_KEY;
		data->hooks -= SHIFT_KEY;
		;/*	data->params.xp_from = 0;
			data->params.xm_from = 0;
			data->params.zp_from = 0;
			data->params.zm_from = 0;
			data->params.p_rotcam_z = 0;
			data->params.m_rotcam_z = 0;
			data->params.p_speed = 0;
			data->params.m_speed = 0;
			data->params.m_rotcam_y = 0;
	x = data->size.val[0] / 4 + pc;
	y = data->size.val[1] / 4;
		//mlx_pixel_put(data->mlx->mlx_ptr, data->mlx->win_ptr, x, y, (img->pixels[img_y * img->width + img_x] & 0xffffff00) >> 8);
	//	mlx_pixel_put(data->mlx->mlx_ptr, data->mlx->win_ptr)
		data->mlx->img_str[y * (int)data->size.val[0] + x] = (img->pixels[img_y * img->width + img_x] & 0xffffff00) >> 8;
	mlx_put_image_to_window(data->mlx->mlx_ptr,
		data->mlx->win_ptr, data->mlx->img_ptr, 0, 0);
	x = data->size.val[0] / 4;
		y = data->size.val[1] / 5;
		y_max = y + data->size.val[1] / 5;
			img_y = (y - data->size.val[1] / 5) * prop_y;
			img_x = (x - data->size.val[0] / 4) * prop_x;
			data->mlx->img_str[y * (int)data->size.val[0] + x] = (img->pixels[img_y * img->width + img_x] & 0xffffff00) >> 8;
	x = data->size.val[0] / 4;
		y = 3 * data->size.val[1] / 5;
		y_max = y + data->size.val[1] / 5;
			img_y = (y - 3 * data->size.val[1] / 5) * prop_y;
			img_x = (x - data->size.val[0] / 4) * prop_x;
			data->mlx->img_str[y * (int)data->size.val[0] + x] = (img->pixels[img_y * img->width + img_x] & 0xffffff00) >> 8;
	//	*data->load_mlx = *data->mlx;
	mlx_put_image_to_window(data->mlx->mlx_ptr,
		data->mlx->win_ptr, data->mlx->img_ptr, 0, 0);
	if (data->params.p_speed)
		data->speed += 0.01;
	else if (data->params.m_speed)
		data->speed -= 0.01;
	if (data->speed < 0.01)
		data->speed = 0.01;
	if (data->params.p_cam_speed)
		data->cam_speed += 0.1;
	else if (data->params.m_cam_speed)
		data->cam_speed -= 0.1;
	if (data->cam_speed < 0.1)
		data->cam_speed = 0.1;
	if (get_magnitude(sub_points(data->cam.from, set_new_point(0, 0, 0)))
		< (data->line_size + data->line_nbr) / 2)
		data->fill = 0;
	data->fun_factor += data->params.fun_on ? 0.1 : -data->fun_factor + 1.0;
	obj = data->objs;
	data->rot_mat[1] = init_rotation_matrix_y(degree_to_radian(3));
		param->origin = mult_3vecf_33matf(param->origin, data->rot_mat[1]);
//	if (data->hooks & F_KEY)
	if (data->selected_obj && data->selected_obj->rotate)
		rot_mat[1]	= init_rotation_matrix_y(degree_to_radian(data->hooks & ARR_LEFT_KEY ? -5 : (data->hooks & ARR_RIGHT_KEY ? 5 : 0)));
	t_3vecf	tm = mult_3vecf_33matf(assign_3vecf(1, 0, 0), data->rot_mat[1]);
	rot_mat[0] = init_rotation_matrix_vec(tm, degree_to_radian(data->hooks & ARR_DOWN_KEY ? 5 : (data->hooks & ARR_UP_KEY ? -5 : 0)));
		if (data->selected_obj->composed_w)
			while (data->selected_obj->composed_w[++i])
				data->selected_obj->composed_w[i]->rotate(data->selected_obj->composed_w[i], data->selected_obj->composed_w[i]->composed_origin, rot_mat);
			data->selected_obj->rotate(data->selected_obj, data->selected_obj->get_origin(data->selected_obj), rot_mat);
	if (data->hooks & (ARR_LEFT_KEY | ARR_RIGHT_KEY))
		/*double	add_y = 4 * data->mouse_x;
	//	if (data->selected_obj && data->selected_obj->rotate)
	//		data->selected_obj->rotate(data->selected_obj->get_origin(data->selected_obj), rot_mat[]);
		if (!data->selected_obj)
			if (data->hooks & ARR_LEFT_KEY)
				data->camera->rotation.val[1] -= 3;
			if (data->hooks & ARR_RIGHT_KEY)
				data->camera->rotation.val[1] += 3;
		//4 * data->mouse_x;
			data->rot_mat[1] = init_rotation_matrix_y(degree_to_radian(data->camera->rotation.val[1]));
	if (data->hooks & (ARR_UP_KEY | ARR_DOWN_KEY))
		/*double	add_y = 4 * data->mouse_x;
		if (!data->selected_obj)
			if (data->hooks & ARR_UP_KEY && data->camera->rotation.val[0] < 90)
				data->camera->rotation.val[0] += 3;
			if (data->hooks & ARR_DOWN_KEY && data->camera->rotation.val[0] > -90)
				data->camera->rotation.val[0] -= 3;
		//4 * data->mouse_x;
	//	data->rot_mat[0] = init_rotation_matrix_vec(mult_3vecf_33matf(assign_3vecf(1, 0, 0), data->rot_mat[1]), degree_to_radian(data->camera->rotation.val[0]));
//	t_3vecf tm = mult_3vecf_33matf(assign_3vecf(1, 0, 0), data->rot_mat[1]);
	/*	double	add_x = -4 * data->mouse_y;
			data->camera->rotation.val[0] += add_x;
		//4 * data->mouse_x;
			data->rot_mat[0] = init_rotation_matrix_x(degree_to_radian(data->camera->rotation.val[0]));
*///	if (data->hooks & G_KEY)
		//data->camera->rotation.val[1] -= 2;
		//data->rot_mat[1] = init_rotation_matrix_y(degree_to_radian(data->camera->rotation.val[1]));
	if (data->hooks & (W_KEY | S_KEY))
		t_3vecf dir = mult_3vecf_33matf(assign_3vecf(0, 0, 0.2), data->rot_mat[1]);
		if (data->hooks & W_KEY)
			if (data->selected_obj)
				if (data->selected_obj->composed_w)
					while (data->selected_obj->composed_w[++i])
						data->selected_obj->composed_w[i]->move(data->selected_obj->composed_w[i], dir, 1);
						data->selected_obj->composed_w[i]->composed_origin = add_3vecf(data->selected_obj->composed_w[i]->composed_origin, dir);
					data->selected_obj->move(data->selected_obj, dir, 1);
				data->camera->origin.val[0] += dir.val[0];
				data->camera->origin.val[1] += dir.val[1];
				data->camera->origin.val[2] += dir.val[2];
		if (data->hooks & S_KEY)
			if (data->selected_obj)
				if (data->selected_obj->composed_w)
					while (data->selected_obj->composed_w[++i])
						data->selected_obj->composed_w[i]->move(data->selected_obj->composed_w[i], dir, -1);
						data->selected_obj->composed_w[i]->composed_origin = sub_3vecf(data->selected_obj->composed_w[i]->composed_origin, dir);
					data->selected_obj->move(data->selected_obj, dir, -1);
				data->camera->origin.val[0] -= dir.val[0];
				data->camera->origin.val[1] -= dir.val[1];
				data->camera->origin.val[2] -= dir.val[2];
		//	data->camera->origin.val[2] -= 0.2;
	if (data->hooks & (A_KEY | D_KEY))
		t_3vecf dir = mult_3vecf_33matf(assign_3vecf(0.2, 0, 0), data->rot_mat[1]);
		if (data->hooks & A_KEY)
			if (data->selected_obj)
				if (data->selected_obj->composed_w)
					while (data->selected_obj->composed_w[++i])
						data->selected_obj->composed_w[i]->move(data->selected_obj->composed_w[i], dir, -1);
						data->selected_obj->composed_w[i]->composed_origin = sub_3vecf(data->selected_obj->composed_w[i]->composed_origin, dir);
					data->selected_obj->move(data->selected_obj, dir, -1);
				data->camera->origin.val[0] -= dir.val[0];
				data->camera->origin.val[1] -= dir.val[1];
				data->camera->origin.val[2] -= dir.val[2];
		//	data->camera->origin.val[0] -= 0.2;
		if (data->hooks & D_KEY)
			if (data->selected_obj)
				if (data->selected_obj->composed_w)
					while (data->selected_obj->composed_w[++i])
						data->selected_obj->composed_w[i]->move(data->selected_obj->composed_w[i], dir, 1);
						data->selected_obj->composed_w[i]->composed_origin = add_3vecf(data->selected_obj->composed_w[i]->composed_origin, dir);
					data->selected_obj->move(data->selected_obj, dir, 1);
				data->camera->origin.val[0] += dir.val[0];
				data->camera->origin.val[1] += dir.val[1];
				data->camera->origin.val[2] += dir.val[2];
		//	data->camera->origin.val[0] += 0.2;
	//	t_3vecf dir = mult_3vecf_33matf(assign_3vecf(0.2, 0, 0), data->rot_mat[1]);
		if (data->hooks & SPACE_KEY)
			if (data->selected_obj)
				if (data->selected_obj->composed_w)
					while (data->selected_obj->composed_w[++i])
						data->selected_obj->composed_w[i]->move(data->selected_obj->composed_w[i], assign_3vecf(0, 0.2, 0), -1);
						data->selected_obj->composed_w[i]->composed_origin = sub_3vecf(data->selected_obj->composed_w[i]->composed_origin, assign_3vecf(0, 0.2, 0));
					data->selected_obj->move(data->selected_obj, assign_3vecf(0, 0.2, 0), -1);
				data->camera->origin.val[1] -= 0.2;
		if (data->hooks & SHIFT_KEY)
			if (data->selected_obj)
				if (data->selected_obj->composed_w)
					while (data->selected_obj->composed_w[++i])
						data->selected_obj->composed_w[i]->move(data->selected_obj->composed_w[i], assign_3vecf(0, 0.2, 0), 1);
						data->selected_obj->composed_w[i]->composed_origin = add_3vecf(data->selected_obj->composed_w[i]->composed_origin, assign_3vecf(0, 0.2, 0));
					data->selected_obj->move(data->selected_obj, assign_3vecf(0, 0.2, 0), 1);
				data->camera->origin.val[1] += 0.2;
			data->camera->origin.val[0] -= dir.val[0];
			data->camera->origin.val[2] -= dir.val[2];
		//	data->camera->origin.val[0] -= 0.2;
	/*	if (data->hooks & D_KEY)
			data->camera->origin.val[0] += dir.val[0];
			data->camera->origin.val[1] += dir.val[1];
			data->camera->origin.val[2] += dir.val[2];
		//	data->camera->origin.val[0] += 0.2;
	if (data->params.p_rotcam_z && !data->params.m_rotcam_z)
		data->mats.teta_z += data->speed;
	else if (data->params.m_rotcam_z && !data->params.p_rotcam_z)
		data->mats.teta_z -= data->speed;
	if (data->params.p_rotcam_x && !data->params.m_rotcam_x)
		data->mats.teta_x += data->speed;
	else if (data->params.m_rotcam_x && !data->params.p_rotcam_x)
		data->mats.teta_x -= data->speed;
	free_matrix(&data->mats.rot_x);
	free_matrix(&data->mats.rot_z);
	free_matrix(&data->mats.world_mat);
	free_matrix(&data->mats.proj_mat);
	data->mats.rot_x = get_rot_x(data->mats.teta_x);
	data->mats.rot_z = get_rot_z(data->mats.teta_z);
	data->mats.world_mat = get_world_matrix(data->cam.from, data);
	if (data->proj == PERSP)
		data->mats.proj_mat = get_projection_matrix(data->cam.fov,
			data->cam.near, data->cam.far);
	else if (data->proj == ORTO)
		data->mats.proj_mat = get_ortho_matrix(data);
	data->f += 0.01;
//	printf("%x\n", data->hooks);
	if ((((data->caustics_gi && !data->caustic_map) || (data->indirect_gi && !data->indirect_map))) && !(create_photon_map(data)))
	mlx_clear_window(data->mlx->mlx_ptr, data->mlx->win_ptr);
//	data->mlx->img_ptr = mlx_new_image(data->mlx->mlx_ptr, WIN_WIDTH, WIN_HEIGHT);
//	data->mlx->img_str = (int *)mlx_get_data_addr(data->mlx->img_ptr,
//			&(data->mlx->bpp), &(data->mlx->s_l), &(data->mlx->endian));
//	display_points(data->pix_map, data->map, data);
//	link_pixels(data->pix_map, data);
	mlx_put_image_to_window(data->mlx->mlx_ptr,
		data->mlx->win_ptr, data->mlx->img_ptr, 0, 0);
	data->delta_time += (SDL_GetTicks() - frame_start);
	//printf("%lu \n", data->delta_time);
	data->fps++;
	if (data->delta_time >= 1000)
		ft_printf("camera position : x %f y %f z %f\nfps: %d\n", data->camera->origin.val[0], data->camera->origin.val[1], data->camera->origin.val[2], data->fps);
		data->fps = 0;
		data->delta_time = 0;
	mlx_destroy_window(data->mlx->mlx_ptr, data->info->win_ptr);
	data->info = NULL;
	free(data->info);
	mlx_hook(data->mlx->win_ptr, 2, 0, key_press, (void *)data);
	mlx_hook(data->mlx->win_ptr, 3, 0, key_release, (void *)data);
	mlx_hook(data->mlx->win_ptr, 4, 0, mouse_hook, (void *)data);
	mlx_hook(data->mlx->win_ptr, 17, (1L << 17), close_cross, (void *)data);
	if (data->info)
		mlx_hook(data->info->win_ptr, 17, 0, close_info, (void *)data);
	mlx_loop_hook(data->mlx->mlx_ptr, &print_loop_image, (void *)data);
	mlx_put_image_to_window(data->mlx->mlx_ptr,
			data->mlx->win_ptr, data->mlx->img_ptr, 0, 0);
	mlx_loop(data->mlx->mlx_ptr);
if (data->objs)
moebius->next = data->objs;
data->objs = moebius;
	if (data->objs)
		monkey_saddle->next = data->objs;
	data->objs = monkey_saddle;
	i = (int)-data->size.val[0] / 2 + x;
	j = (int)-data->size.val[1] / 2 + y;
		if (data->selected_obj)
			data->selected_obj = NULL;
			t_3vecf orig = data->camera->origin;
			t_3vecf	dir = mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i, j, data->size.val[0], data->size.val[1]), data->rot_mat[1]), data->rot_mat[0]);
			data->selected_obj = ray_first_intersect(orig, dir, BIAS, MAX_VIEW, &dist, data->objs, 0, data);
	data->mouse_x = x;
	data->mouse_y = y;
//	printf("%d %d\n", data->mouse_x, data->mouse_y);
	data->mouse_x = (double)x * 2 / (double)WIN_WIDTH - 1;
	data->mouse_y = 0;//(double)y * 2 / (double)WIN_HEIGHT - 1;
	printf("%d %d => %f %f\n",x, y,  data->mouse_x, data->mouse_y);
	if (data->composed_objs)
		composed->next = data->composed_objs;
	data->composed_objs = composed;
	list = data->composed_objs;
	if (!data->skybox_name)
	if (!(image = parse_img(data->skybox_name)))
	tmp = data->lights;
		if (data->lights)
			light->next = data->lights;
		data->lights = light;
	if (!data->camera)
	if (data->lights)
		light->next = data->lights;
	data->lights = light;
		data->apply_color_filter = &apply_color_filter_sepia;
	if (s[i] != '(' || (i = parse_2vecf(s, i, &data->size)) == -1)
	if (data->camera)
	data->camera = cam;
	if (!data->camera || ret == 0)
		ret = parse_onoff(line, &data->motion_blur);
		ret = parse_onoff(line, &data->stereoscopy);
		ret = parse_onoff(line, &data->anti_al);
		ret = parse_onoff(line, &data->cel_shading);
		ret = parse_onoff(line, &data->indirect_gi);
		ret = parse_onoff(line, &data->caustics_gi);
		ret = parse_rotation(line, &data->fog, 3);
		ret = parse_name(line, &data->skybox_name, 6);
			ret = parse_name(line, &data->scene_name, 4);
		if (!depth || is_null_3vecf(pwr) || !(obj = ray_first_intersect(orig, dir, BIAS, MAX_VIEW, &dist, data->objs, 0, data)))
	if (data->caustics_gi)
	if (data->indirect_gi)
	if (!check_light_type(data->lights))
	light = data->lights;
		light = light->next ? light->next : data->lights;
	if (!data->objs)
//	data->bbox_photon.x_range.val[0] = MAX_VIEW;
//	data->bbox_photon.y_range.val[0] = MAX_VIEW;
//	data->bbox_photon.z_range.val[0] = MAX_VIEW;
//	data->bbox_photon.x_range.val[1] = -MAX_VIEW;
//	data->bbox_photon.y_range.val[1] = -MAX_VIEW;
//	data->bbox_photon.z_range.val[1] = -MAX_VIEW;
	data->caustic_map = photon_tab[0] ? build_kd_tree(photon_tab[0], 0, NB_CAUSTIC_PHOTON - 1, 0, &data->bbox_photon) : NULL;
	data->indirect_map = build_kd_tree(photon_tab[1], 0, NB_INDIRECT_PHOTON - 1, 0, &data->bbox_photon);
	printf("Bounding box photon scene: \nx %f %f\n", data->bbox_photon.x_range.val[0], data->bbox_photon.x_range.val[1]);
	printf("y %f %f\n", data->bbox_photon.y_range.val[0], data->bbox_photon.y_range.val[1]);
	printf("z %f %f\n", data->bbox_photon.z_range.val[0], data->bbox_photon.z_range.val[1]);
//	data->caustic_map = kd_tree;
	return (data->caustic_map || data->indirect_map ? 1 : 0);
if (data->objs)
plane->next = data->objs;
data->objs = plane;
	negative_objs = data->negative_objs;
	if (closest_obj && data->negative_objs)
	if (data->caustics_gi)
		global = compute_global_illumination(inter_point, normal_inter, data->caustic_map, MAX_CAUSTIC_RADIUS, NN_CAUSTIC_PHOTON_MAX);
	if (data->indirect_gi)
		global = compute_global_illumination(inter_point, normal_inter, data->indirect_map, MAX_INDIRECT_RADIUS, NN_INDIRECT_PHOTON_MAX);
	if (data->cel_shading)
	closest_obj = ray_first_intersect(orig, dir, min_dist, max_dist, &closest_dist, data->objs, sp_id, data);
		light_fact = compute_glare(orig, dir, data->lights, NULL);
		if (data->fog.val[0] || data->fog.val[1])
			if (closest_dist < data->fog.val[0])
			else if (closest_dist < data->fog.val[1])
				fog_fact = (data->fog.val[1] - closest_dist) / (data->fog.val[1] - data->fog.val[0]);
		light_fact = compute_lights(inter_point, normal_inter, dir, data->lights, data->objs, sp_id, data, closest_obj->shininess);
	if (data->cel_shading && is_on_cell_boundary(orig, inter_point, normal_inter, closest_obj, sp_id))
/*		light_fact = compute_lights(inter_point, normal_inter, inv_dir, data->lights, data->objs);
	/*	light_fact = compute_lights(inter_point, normal_inter, inv_dir, data->lights, data->objs);
	/*	light_fact = compute_lights(inter_point, normal_inter, inv_dir, data->lights, data->objs);
		light_fact = compute_lights(inter_point, normal_inter, inv_dir, data->lights, data->objs);
	if (data->fog.val[0] || data->fog.val[1])
		if (closest_dist < data->fog.val[0])
		else if (closest_dist < data->fog.val[1])
			fog_fact = (data->fog.val[1] - closest_dist) / (data->fog.val[1] - data->fog.val[0]);
		t_3vecf	glare = compute_glare(orig, dir, data->lights, &inter_point);
	i = (int)data->size.val[0] / 2 + i;
	j = (int)data->size.val[1] / 2 + j;
	if (data->apply_color_filter)
		color = data->apply_color_filter(color);
	img[j * (int)data->size.val[0] + i] = rgb_color;
		threads[index].start = (int)-data->size.val[0] / 2 + (int)data->size.val[0] * index / NB_THREADS;
		threads[index].end = (int)-data->size.val[0] / 2 + (int)data->size.val[0] * (index + 1) / NB_THREADS;
	orig = data->camera->origin;
		j = -data->size.val[1] / 2;
		while (j < data->size.val[1] / 2)
			if (data->stereoscopy)
				diff = mult_3vecf_33matf(assign_3vecf(0.1, 0, 0), data->rot_mat[1]);
				dir = mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i, j, data->size.val[0], data->size.val[1]), data->rot_mat[1]), data->rot_mat[0]);
				if (!data->motion_blur)
				ray_put_pixel(i, j, data->mlx->img_str, color, data);
			else if (!data->anti_al)
				dir = mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i, j, data->size.val[0], data->size.val[1]), data->rot_mat[1]), data->rot_mat[0]);
				if (!data->motion_blur)
				ray_put_pixel(i, j, data->mlx->img_str, color, data);
				anti_all_iter = data->anti_al * data->anti_al;
					dir = mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i * data->anti_al + offset / data->anti_al, j * data->anti_al + offset % data->anti_al, WIN_WIDTH * data->anti_al, WIN_HEIGHT * data->anti_al), data->rot_mat[1]), data->rot_mat[0]);
				ray_put_pixel(i, j, data->mlx->img_str, color, data);
				aa = data->aa_adapt;
				anti_all_iter = data->aa_adapt * data->aa_adapt;
					dir = mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i * aa + offset / aa, j * aa + offset % aa, (int)data->size.val[0] * aa, (int)data->size.val[1] * aa), data->rot_mat[1]), data->rot_mat[0]);
				ray_put_pixel(i, j, data->mlx->img_str, color, data);
				if (data->aa_adapt == MIN_ANTI_AL)
					if ((i + 1) * 2 != data->size.val[0])
						ray_put_pixel(i + 1, j, data->mlx->img_str, color, data);
					if ((j + 1) * 2 != data->size.val[1])
						ray_put_pixel(i, j + 1, data->mlx->img_str, color, data);
					if ((j + 1) * 2 != data->size.val[1] && (i + 1) * 2 != data->size.val[0])
						ray_put_pixel(i + 1, j + 1, data->mlx->img_str, color, data);
			if (data->aa_adapt == MIN_ANTI_AL)
		if (data->aa_adapt == MIN_ANTI_AL)
//	orig = data->camera->origin;
	//dir = mult_3vecf_33matf(window_to_view(0, 0), data->rot_mat[1]);
	t_3vecf tm = mult_3vecf_33matf(assign_3vecf(1, 0, 0), data->rot_mat[1]);
	data->rot_mat[0] = init_rotation_matrix_vec(tm, degree_to_radian(data->camera->rotation.val[0]));
	//data->rot_mat[2] = init_rotation_matrix_z(degree_to_radian(data->camera->rotation.val[0]) * tm.val[2]);
	//rot_mat[1] = init_rotation_matrix_y(degree_to_radian(data->camera->rotation.val[1]));
	//rot_mat[2] = init_rotation_matrix_z(degree_to_radian(data->camera->rotation.val[2]));
	closest_obj = ray_first_intersect(orig, dir, min_dist, max_dist, &closest_dist, data->objs);
	light_fact = compute_lights(inter_point, normal_inter, assign_3vecf(-dir.val[0], -dir.val[1], -dir.val[2]), data->lights, data->objs);
	i = (WIN_WIDTH * data->anti_al / 2 + i) / data->anti_al;
	j = (WIN_HEIGHT * data->anti_al / 2 + j) / data->anti_al;
		threads[index].start = -WIN_WIDTH * data->anti_al / 2 + WIN_WIDTH * data->anti_al * index / NB_THREADS;		
		threads[index].end = -WIN_WIDTH * data->anti_al / 2 + WIN_WIDTH * data->anti_al * (index + 1) / NB_THREADS;
	i_end = i + data->anti_al;
	j_end = j + data->anti_al;
			dir = mult_3vecf_33matf(mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i, j, data->anti_al), data->rot_mat[1]), data->rot_mat[0]), data->rot_mat[2]);
		j -= data->anti_al;
	while (clr_index < data->anti_al * data->anti_al)
	orig = data->camera->origin;
		j = -WIN_HEIGHT * data->anti_al / 2;
		while (j < WIN_HEIGHT * data->anti_al / 2)
			//dir = mult_3vecf_33matf(mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i, j), data->rot_mat[1]), data->rot_mat[0]), data->rot_mat[2]);
			/*dir = mult_3vecf_33matf(window_to_view(i, j), data->rot_mat[1]);
			dir_t = mult_3vecf_33matf(window_to_view(i, j), data->rot_mat[0]);
			*///dir = mult_3vecf_33matf(window_to_view(i, j), mult_33matf_33matf(data->rot_mat[1], data->rot_mat[0]));
			ray_put_pixel(i, j, data->mlx->img_str, color, data);
			j += data->anti_al;
		i += data->anti_al;
//	orig = data->camera->origin;
	//dir = mult_3vecf_33matf(window_to_view(0, 0), data->rot_mat[1]);
	t_3vecf tm = mult_3vecf_33matf(assign_3vecf(1, 0, 0), data->rot_mat[1]);
	data->rot_mat[0] = init_rotation_matrix_x(degree_to_radian(data->camera->rotation.val[0]) * tm.val[0]);
	data->rot_mat[2] = init_rotation_matrix_z(degree_to_radian(data->camera->rotation.val[0]) * tm.val[2]);
	//rot_mat[1] = init_rotation_matrix_y(degree_to_radian(data->camera->rotation.val[1]));
	//rot_mat[2] = init_rotation_matrix_z(degree_to_radian(data->camera->rotation.val[2]));
	closest_obj = ray_first_intersect(orig, dir, min_dist, max_dist, &closest_dist, data->objs);
*/	light_fact = compute_lights(inter_point, normal_inter, inv_dir, data->lights, data->objs);
	orig = data->camera->origin;
			dir = /*mult_3vecf_33matf(*/mult_3vecf_33matf(mult_3vecf_33matf(window_to_view(i, j), data->rot_mat[1]), data->rot_mat[0])/*, data->rot_mat[2])*/;
			/*dir = mult_3vecf_33matf(window_to_view(i, j), data->rot_mat[1]);
			dir_t = mult_3vecf_33matf(window_to_view(i, j), data->rot_mat[0]);
			*///dir = mult_3vecf_33matf(window_to_view(i, j), mult_33matf_33matf(data->rot_mat[1], data->rot_mat[0]));
			ray_put_pixel(i, j, data->mlx->img_str, color);
//	orig = data->camera->origin;
	//dir = mult_3vecf_33matf(window_to_view(0, 0), data->rot_mat[1]);
	t_3vecf tm = mult_3vecf_33matf(assign_3vecf(1, 0, 0), data->rot_mat[1]);
	data->rot_mat[0] = init_rotation_matrix_vec(tm, degree_to_radian(data->camera->rotation.val[0]));
	//data->rot_mat[2] = init_rotation_matrix_z(degree_to_radian(data->camera->rotation.val[0]) * tm.val[2]);
	//rot_mat[1] = init_rotation_matrix_y(degree_to_radian(data->camera->rotation.val[1]));
	//rot_mat[2] = init_rotation_matrix_z(degree_to_radian(data->camera->rotation.val[2]));
	objects = data->objs;
	lights = data->lights;
	if ((hit_object = ray_trace(orig, dir, data->objs, &dist)))
			t_obj	*hit_shadow = ray_trace(shadow_point_orig, light_dir, data->objs, &shadow_n_dist); 
	//		t_obj	*hit_shadow = ray_trace(hit_point, m_light_dir, data->objs, &l_dist); 
		mult_dir_matrix(assign_3vecf(x[ind], y[ind], -1), data->camera_to_world, &dir);
	print_mat(data->camera_to_world.val);
	scale = tan(degree_to_radian(data->fov * 0.5));
	mult_vec_matrix(assign_3vecf(0, 0, 0), data->camera_to_world, &orig);
			data->mlx->img_str[(i / 4) * WIN_WIDTH + (j / 4)] = anti_aliasing(i, j, img_aspect_ratio, scale, orig, data);
			mult_dir_matrix(assign_3vecf(x, y, -1), data->camera_to_world, &dir);
			data->mlx->img_str[i * WIN_WIDTH + j] = cast_ray(orig, dir, data);
if (data->objs)
sphere->next = data->objs;
data->objs = sphere;
if (data->objs)
triangle->next = data->objs;
data->objs = triangle;
